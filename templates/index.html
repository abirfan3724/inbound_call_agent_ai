<!doctype html>
<html lang="bn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Voice Demo</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 24px; }
      button { font-size: 18px; padding: 12px 20px; cursor: pointer; }
      #log { margin-top: 16px; color: #444; white-space: pre-line; }
    </style>
  </head>
  <body>
    <button id="startBtn">Start Voice</button>
    <div id="log"></div>

    <script>
      const log = (msg) => {
        const el = document.getElementById('log');
        el.textContent = msg;
      };

      function pickVoice(preferredLangs = ['bn-BD','bn','en-US','en']) {
        const synth = window.speechSynthesis;
        const voices = synth.getVoices();
        for (const lang of preferredLangs) {
          const v = voices.find(vc => (vc.lang || '').toLowerCase().startsWith(lang.toLowerCase()));
          if (v) return v;
        }
        return voices[0] || null;
      }

      function speak(text) {
        return new Promise((resolve, reject) => {
          if (!('speechSynthesis' in window)) return reject('Speech Synthesis not supported');
          const utter = new SpeechSynthesisUtterance(text);
          const setVoice = () => {
            const voice = pickVoice();
            if (voice) utter.voice = voice;
            utter.rate = 1; // adjust if needed
            utter.pitch = 1;
            window.speechSynthesis.speak(utter);
          };
          utter.onend = resolve;
          utter.onerror = (e) => reject(e.error || 'speak error');
          // voices may load async
          if (speechSynthesis.getVoices().length === 0) {
            speechSynthesis.onvoiceschanged = setVoice;
          } else {
            setVoice();
          }
        });
      }

      function listenOnce(lang = 'bn-BD') {
        return new Promise((resolve, reject) => {
          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SR) return reject('Speech Recognition not supported');
          const rec = new SR();
          rec.lang = lang;
          rec.interimResults = false;
          rec.maxAlternatives = 1;
          let done = false;
          rec.onresult = (e) => {
            const transcript = e.results[0][0].transcript;
            done = true;
            rec.stop();
            resolve(transcript);
          };
          rec.onerror = (e) => { if (!done) reject(e.error || 'listen error'); };
          rec.onend = () => { if (!done) resolve(''); };
          rec.start();
        });
      }

      async function handleStart() {
        try {
          log('Loading promotion...');
          const res = await fetch('/start');
          const data = await res.json();
          const promo = data.text || '';
          log('Speaking promotion...');
          await speak(promo);

          log('Say something about "promotion" or "release"...');
          let transcript = '';
          try {
            transcript = await listenOnce('bn-BD');
            if (!transcript) transcript = await listenOnce('en-US');
          } catch (e) {
            // fallback to prompt if recognition not supported
            transcript = prompt('Ask about promotion or release:') || '';
          }

          if (!transcript) {
            log('No voice captured.');
            await speak('I did not catch that.');
            return;
          }

          log('Heard: ' + transcript + '\nGetting answer...');
          const ansRes = await fetch('/ask', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ q: transcript })
          });
          const ans = await ansRes.json();
          log('Answer: ' + ans.answer);
          await speak(ans.answer);
        } catch (e) {
          console.error(e);
          log('Error: ' + e);
          try { await speak('An error occurred.'); } catch {}
        }
      }

      document.getElementById('startBtn').addEventListener('click', handleStart);
    </script>
  </body>
  </html>

